import { EtherpadConfiguration } from './types';
export interface Group {
    groupID: string;
}
export interface GroupMapper {
    groupMapper: string;
}
export interface Author {
    authorID: string;
}
export interface AuthorSession extends Author, Group {
    validUntil: number;
}
export interface AuthorName {
    name?: string;
}
export interface AuthorMapper extends AuthorName {
    authorMapper: string;
}
export interface Session {
    sessionID: string;
}
export interface PadReadOnly {
    readOnlyID: string;
}
export interface Pad {
    padID: string;
}
export interface PadHtml extends Pad {
    html: string;
}
export interface PadHtmlDiff extends Pad {
    startRev: string;
    endRev: string;
}
export interface PadDestination extends Pad {
    destinationID: string;
    force?: boolean;
}
export interface GroupPad extends Pad {
    padName: string;
    text?: string;
}
export interface PadRev extends Pad {
    rev: string;
}
export interface PadOptionalRev extends Pad {
    rev?: string;
}
export interface PadText extends Pad {
    text: string;
}
export interface PadOptionalText extends Pad {
    text?: string;
}
export interface PadPublicStatus extends Pad {
    publicStatus: boolean;
}
export interface PadPassword extends Pad {
    password: string;
}
export interface PadMessage extends Pad {
    msg: string;
}
export interface PadChatHistory extends Pad {
    start?: number;
    end?: number;
}
export interface PadChatMessage extends PadText, Author {
    time?: number;
}
export default class Etherpad {
    private _apiUrl;
    private _apiVersion;
    private _apiKey;
    private _timeout;
    constructor(config: EtherpadConfiguration);
    private _getParams;
    private _query;
    private _checkVersion;
    createGroup(qs?: void, throwOnEtherpadError?: boolean): Promise<any>;
    createGroupIfNotExistsFor(qs: GroupMapper, throwOnEtherpadError?: boolean): Promise<any>;
    deleteGroup(qs: Group, throwOnEtherpadError?: boolean): Promise<any>;
    listPads(qs: Group, throwOnEtherpadError?: boolean): Promise<any>;
    createGroupPad(qs: GroupPad, throwOnEtherpadError?: boolean): Promise<any>;
    listAllGroups(qs?: void, throwOnEtherpadError?: boolean): Promise<any>;
    createAuthor(qs: AuthorName, throwOnEtherpadError?: boolean): Promise<any>;
    createAuthorIfNotExistsFor(qs: AuthorMapper, throwOnEtherpadError?: boolean): Promise<any>;
    listPadsOfAuthor(qs: Author, throwOnEtherpadError?: boolean): Promise<any>;
    getAuthorName(qs: Author, throwOnEtherpadError?: boolean): Promise<any>;
    createSession(qs: AuthorSession, throwOnEtherpadError?: boolean): Promise<any>;
    deleteSession(qs: Session, throwOnEtherpadError?: boolean): Promise<any>;
    getSessionInfo(qs: Session, throwOnEtherpadError?: boolean): Promise<any>;
    listSessionsOfGroup(qs: Group, throwOnEtherpadError?: boolean): Promise<any>;
    listSessionsOfAuthor(qs: Author, throwOnEtherpadError?: boolean): Promise<any>;
    getText(qs: PadOptionalRev, throwOnEtherpadError?: boolean): Promise<any>;
    setText(qs: PadText, throwOnEtherpadError?: boolean): Promise<any>;
    appendText(qs: PadText, throwOnEtherpadError?: boolean): Promise<any>;
    getHTML(qs: PadOptionalRev, throwOnEtherpadError?: boolean): Promise<any>;
    setHTML(qs: PadHtml, throwOnEtherpadError?: boolean): Promise<any>;
    getAttributePool(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    getRevisionChangeset(qs: PadOptionalRev, throwOnEtherpadError?: boolean): Promise<any>;
    createDiffHTML(qs: PadHtmlDiff, throwOnEtherpadError?: boolean): Promise<any>;
    restoreRevision(qs: PadRev, throwOnEtherpadError?: boolean): Promise<any>;
    getChatHistory(qs: PadChatHistory, throwOnEtherpadError?: boolean): Promise<any>;
    getChatHead(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    appendChatMessage(qs: PadChatMessage, throwOnEtherpadError?: boolean): Promise<any>;
    createPad(qs: PadOptionalText, throwOnEtherpadError?: boolean): Promise<any>;
    getRevisionsCount(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    getSavedRevisionsCount(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    listSavedRevisions(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    saveRevision(qs: PadOptionalRev, throwOnEtherpadError?: boolean): Promise<any>;
    padUsersCount(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    padUsers(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    deletePad(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    copyPad(qs: PadDestination, throwOnEtherpadError?: boolean): Promise<any>;
    movePad(qs: PadDestination, throwOnEtherpadError?: boolean): Promise<any>;
    getReadOnlyID(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    getPadID(qs: PadReadOnly, throwOnEtherpadError?: boolean): Promise<any>;
    setPublicStatus(qs: PadPublicStatus, throwOnEtherpadError?: boolean): Promise<any>;
    getPublicStatus(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    setPassword(qs: PadPassword, throwOnEtherpadError?: boolean): Promise<any>;
    isPasswordProtected(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    listAuthorsOfPad(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    getLastEdited(qs: Pad, throwOnEtherpadError?: boolean): Promise<any>;
    sendClientsMessage(qs: PadMessage, throwOnEtherpadError?: boolean): Promise<any>;
    checkToken(qs?: void, throwOnEtherpadError?: boolean): Promise<any>;
    listAllPads(qs?: void, throwOnEtherpadError?: boolean): Promise<any>;
}
